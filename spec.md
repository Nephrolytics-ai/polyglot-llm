We are going to make an abstraction layer for LLMs.
All abstractions will go in the pkg/model/llm.go file 
Implementations will go in pkg/llms/* You can see I seeded the directory with a list of LLMs we want to support, but feel free to add more as needed.

the Base LLM interface will have the following methods:
 - CreateStructuredGenerator[T any](ctx context.Context,prompt string, opts GeneratorOpts...) (Generator[T], error)
 - CreateGenerator(ctx context.Context,prompt string, opts GeneratorOpts...) (Generator[string], error)

The generator will be typed as above and will have the following methods:
 - Generate(ctx context.Context) (T, error)
 
GeneratorOpts wiill be a typical golang Option style that supports the following options:
 - Temperature(float64)
 - MaxTokens(int)
 - Tools([]Tool) // tools will be defined in a future PR, but for now just assume it's an interface that represents an external tool the LLM can call during generation.

A Tool defines an external function that the LLM can call during generation. It has the following interface:
 - Name string
 - Description string
 - InputSchema any // this will be used to generate the JSON schema for the tool's input, which the LLM can use to call the tool correctly.
 - OutputSchema any // this will be used to generate the JSON schema for the tool's output, which the LLM can use to parse the tool's response correctly.
Use the logging abstraction we have in pkg/model/Logger and NewLogger(ctx context.Context) method to log any relevant information during generation, such as the prompt, options, and any errors that occur.
Never use fatal or panic in this code, always return errors and let the caller decide how to handle them.
Wrap the errors in utils.WrapIfNotNil with the function name as context before returning them with function name as context before returning them.



Define an an interface in pkg/model/Logger called LoggerFactory that has a single CreateLogger(ctx context.Context) Logger method that returns a Logger instance. 
And create a SetLoggerFactory method that sets a global LoggerFactory instance
In the pkg/logging directory generate a implementation of the pkg/model/Logger interface that uses logrus.
Then create a NewLogger(ctx context.Context) method that returns returns a logger generated by the logger factory instance
or returns a logrus logger if the factory is nil.


When implementing the model for different LLMS, 
Map ContextMessageType type strings to the appropriate message types for each LLM. 
When generating a LLM implementation, return error if an invalid LLM option is provided.

